<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curling Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #87CEEB, #E0F6FF);
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        .game-container {
            text-align: center;
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        canvas {
            border: 3px solid #2c3e50;
            border-radius: 10px;
            background: linear-gradient(to bottom, #E8F4FD 0%, #B8E0FF 100%);
            cursor: crosshair;
        }
        
        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 15px 0;
            font-size: 18px;
            font-weight: bold;
        }
        
        .score {
            color: #2c3e50;
        }
        
        .power-meter {
            margin: 10px 0;
        }
        
        .power-bar {
            width: 300px;
            height: 20px;
            background: #ddd;
            border-radius: 10px;
            overflow: hidden;
            margin: 0 auto;
            border: 2px solid #2c3e50;
        }
        
        .power-fill {
            height: 100%;
            background: linear-gradient(to right, #27ae60, #f1c40f, #e74c3c);
            width: 0%;
            transition: width 0.1s;
        }
        
        .controls {
            margin-top: 15px;
            color: #555;
            font-size: 14px;
        }
        
        .turn-indicator {
            font-size: 20px;
            margin: 10px 0;
            padding: 10px;
            border-radius: 8px;
        }
        
        .player1-turn {
            background: #3498db;
            color: white;
        }
        
        .player2-turn {
            background: #e74c3c;
            color: white;
        }
        
        .game-over {
            font-size: 24px;
            color: #27ae60;
            margin: 15px 0;
            font-weight: bold;
        }
        
        .end-result {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            font-size: 18px;
            font-weight: bold;
        }
        
        .end-result.player1-scored {
            background: #d4edda;
            border-color: #3498db;
            color: #2c3e50;
        }
        
        .end-result.player2-scored {
            background: #f8d7da;
            border-color: #e74c3c;
            color: #2c3e50;
        }
        
        .waiting-message {
            font-size: 16px;
            color: #666;
            margin: 10px 0;
            font-style: italic;
        }
        
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
        }
        
        button:hover {
            background: #2980b9;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>ğŸ¥Œ Curling Game</h1>
        
        <div class="game-info">
            <div class="score">Player 1 (Blue): <span id="player1Score">0</span></div>
            <div class="score">End: <span id="currentEnd">1</span> / <span id="maxEnds">6</span></div>
            <div class="score">Player 2 (Red): <span id="player2Score">0</span></div>
        </div>
        
        <div id="turnIndicator" class="turn-indicator player1-turn">
            Player 1's Turn - Stone <span id="stoneNumber">1</span>/8 - Click and drag to aim and set power
        </div>
        
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div class="power-meter">
            <div>Power: <span id="powerValue">0</span>%</div>
            <div class="power-bar">
                <div id="powerFill" class="power-fill"></div>
            </div>
        </div>
        
        <div class="controls">
            <p><strong>How to play:</strong></p>
            <p>â€¢ Click and drag from the throwing area to aim and set power</p>
            <p>â€¢ Release to throw your stone</p>
            <p>â€¢ ê° í”Œë ˆì´ì–´ê°€ ë²ˆê°ˆì•„ê°€ë©° ëŒì„ ë˜ì§‘ë‹ˆë‹¤ (ì´ 8ê°œì”©)</p>
            <p>â€¢ íƒ€ê²Ÿ ì¤‘ì‹¬ì— ê°€ì¥ ê°€ê¹Œìš´ ëŒì˜ íŒ€ì´ ì ìˆ˜ë¥¼ ì–»ìŠµë‹ˆë‹¤</p>
            <p>â€¢ ìƒëŒ€ë°©ë³´ë‹¤ ê°€ê¹Œìš´ ëª¨ë“  ëŒì´ ì ìˆ˜ê°€ ë©ë‹ˆë‹¤</p>
            <p>â€¢ 6ì—”ë“œë¥¼ ì§„í–‰í•˜ì—¬ ì´ì ì´ ë†’ì€ íŒ€ì´ ìŠ¹ë¦¬í•©ë‹ˆë‹¤</p>
        </div>
        
        <div id="gameOver" class="game-over" style="display: none;"></div>
        <div id="endResult" class="end-result" style="display: none;"></div>
        <div id="waitingMessage" class="waiting-message" style="display: none;">ëŒë“¤ì´ ë©ˆì¶œ ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...</div>
        <button id="newGameBtn" onclick="startNewGame()" style="display: none;">New Game</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        let currentPlayer = 1;
        let player1Score = 0;
        let player2Score = 0;
        let currentEnd = 1;
        let stonesThrown = 0;
        let maxEnds = 6; // ë¹ ë¥¸ ê²Œì„ì„ ìœ„í•´ 6ì—”ë“œ
        let gameOver = false;
        let stonesPerPlayer = 8; // ê° í”Œë ˆì´ì–´ë‹¹ 8ê°œì˜ ëŒ
        let endInProgress = false;
        let waitingForStones = false;
        
        // Sound effects (Web Audio APIë¥¼ ì‚¬ìš©í•œ ê°„ë‹¨í•œ ì‚¬ìš´ë“œ)
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(frequency, duration, type = 'sine') {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = frequency;
            oscillator.type = type;
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }
        
        function playThrowSound() {
            playSound(200, 0.3, 'sine');
        }
        
        function playCollisionSound() {
            playSound(400, 0.2, 'square');
        }
        
        function playScoreSound() {
            // ì ìˆ˜ íšë“ ì‹œ ë©œë¡œë””
            setTimeout(() => playSound(523, 0.2), 0);    // C
            setTimeout(() => playSound(659, 0.2), 200);  // E
            setTimeout(() => playSound(784, 0.3), 400);  // G
        }
        
        function playEndSound() {
            // ê²Œì„ ì¢…ë£Œ ì‹œ íŒ¡íŒŒë ˆ
            setTimeout(() => playSound(523, 0.3), 0);
            setTimeout(() => playSound(659, 0.3), 300);
            setTimeout(() => playSound(784, 0.3), 600);
            setTimeout(() => playSound(1047, 0.5), 900);
        }
        
        // Stones array
        let stones = [];
        
        // Mouse/touch state
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let dragEnd = { x: 0, y: 0 };
        let power = 0;
        
        // Game constants
        const STONE_RADIUS = 15;
        const TARGET_CENTER = { x: canvas.width / 2, y: 100 };
        const TARGET_RADIUS = 80;
        const THROWING_AREA = { x: canvas.width / 2, y: canvas.height - 50 };
        const FRICTION = 0.98;
        const MIN_VELOCITY = 0.1;
        
        // Stone class
        class Stone {
            constructor(x, y, vx, vy, player) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.player = player;
                this.radius = STONE_RADIUS;
                this.moving = true;
            }
            
            update() {
                if (!this.moving) return;
                
                // Apply velocity
                this.x += this.vx;
                this.y += this.vy;
                
                // Apply friction
                this.vx *= FRICTION;
                this.vy *= FRICTION;
                
                // Stop if velocity is too low
                if (Math.abs(this.vx) < MIN_VELOCITY && Math.abs(this.vy) < MIN_VELOCITY) {
                    this.vx = 0;
                    this.vy = 0;
                    this.moving = false;
                }
                
                // Boundary collision
                if (this.x - this.radius < 0 || this.x + this.radius > canvas.width) {
                    this.vx *= -0.8;
                    this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
                }
                
                if (this.y - this.radius < 0 || this.y + this.radius > canvas.height) {
                    this.vy *= -0.8;
                    this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));
                }
            }
            
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                
                // Stone color based on player
                if (this.player === 1) {
                    ctx.fillStyle = '#3498db';
                    ctx.strokeStyle = '#2980b9';
                } else {
                    ctx.fillStyle = '#e74c3c';
                    ctx.strokeStyle = '#c0392b';
                }
                
                ctx.fill();
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Add stone handle/grip
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 0.4, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.fill();
                ctx.strokeStyle = '#34495e';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }
        
        // Check collision between stones
        function checkStoneCollisions() {
            for (let i = 0; i < stones.length; i++) {
                for (let j = i + 1; j < stones.length; j++) {
                    const stone1 = stones[i];
                    const stone2 = stones[j];
                    
                    const dx = stone2.x - stone1.x;
                    const dy = stone2.y - stone1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < stone1.radius + stone2.radius) {
                        // Collision detected - simple elastic collision
                        const angle = Math.atan2(dy, dx);
                        const sin = Math.sin(angle);
                        const cos = Math.cos(angle);
                        
                        // Separate stones
                        const overlap = (stone1.radius + stone2.radius) - distance;
                        stone1.x -= overlap * 0.5 * cos;
                        stone1.y -= overlap * 0.5 * sin;
                        stone2.x += overlap * 0.5 * cos;
                        stone2.y += overlap * 0.5 * sin;
                        
                        // Exchange velocities (simplified)
                        const tempVx = stone1.vx;
                        const tempVy = stone1.vy;
                        stone1.vx = stone2.vx * 0.8;
                        stone1.vy = stone2.vy * 0.8;
                        stone2.vx = tempVx * 0.8;
                        stone2.vy = tempVy * 0.8;
                        
                        stone1.moving = true;
                        stone2.moving = true;
                        
                        // Play collision sound
                        playCollisionSound();
                    }
                }
            }
        }
        
        // Draw game elements
        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw ice texture
            drawIce();
            
            // Draw target
            drawTarget();
            
            // Draw throwing area
            drawThrowingArea();
            
            // Draw stones
            stones.forEach(stone => stone.draw());
            
            // Draw aiming line if dragging
            if (isDragging && !gameOver && !waitingForStones) {
                drawAimingLine();
            }
        }
        
        function drawIce() {
            // Ice surface with subtle pattern
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, 'rgba(200, 230, 255, 0.3)');
            gradient.addColorStop(1, 'rgba(150, 200, 255, 0.3)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw ice lines
            ctx.strokeStyle = 'rgba(100, 150, 200, 0.3)';
            ctx.lineWidth = 1;
            for (let i = 0; i < canvas.width; i += 40) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
        }
        
        function drawTarget() {
            // Target circles
            const circles = [
                { radius: TARGET_RADIUS, color: '#e74c3c', alpha: 0.3 },
                { radius: TARGET_RADIUS * 0.75, color: '#f1c40f', alpha: 0.3 },
                { radius: TARGET_RADIUS * 0.5, color: '#27ae60', alpha: 0.3 },
                { radius: TARGET_RADIUS * 0.25, color: '#3498db', alpha: 0.5 }
            ];
            
            circles.forEach(circle => {
                ctx.beginPath();
                ctx.arc(TARGET_CENTER.x, TARGET_CENTER.y, circle.radius, 0, Math.PI * 2);
                ctx.fillStyle = circle.color;
                ctx.globalAlpha = circle.alpha;
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.strokeStyle = circle.color;
                ctx.lineWidth = 2;
                ctx.stroke();
            });
            
            // Center dot
            ctx.beginPath();
            ctx.arc(TARGET_CENTER.x, TARGET_CENTER.y, 5, 0, Math.PI * 2);
            ctx.fillStyle = '#2c3e50';
            ctx.fill();
        }
        
        function drawThrowingArea() {
            // Throwing line
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, THROWING_AREA.y);
            ctx.lineTo(canvas.width, THROWING_AREA.y);
            ctx.stroke();
            
            // Throwing position indicator
            ctx.beginPath();
            ctx.arc(THROWING_AREA.x, THROWING_AREA.y, 10, 0, Math.PI * 2);
            ctx.fillStyle = currentPlayer === 1 ? '#3498db' : '#e74c3c';
            ctx.fill();
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        function drawAimingLine() {
            ctx.strokeStyle = currentPlayer === 1 ? '#3498db' : '#e74c3c';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);
            ctx.beginPath();
            ctx.moveTo(THROWING_AREA.x, THROWING_AREA.y);
            ctx.lineTo(dragEnd.x, dragEnd.y);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Power indicator
            const distance = Math.sqrt(
                Math.pow(dragEnd.x - THROWING_AREA.x, 2) + 
                Math.pow(dragEnd.y - THROWING_AREA.y, 2)
            );
            power = Math.min(100, (distance / 200) * 100);
            
            document.getElementById('powerValue').textContent = Math.round(power);
            document.getElementById('powerFill').style.width = power + '%';
        }
        
        // Calculate score for current end
        function calculateEndScore() {
            if (stones.length === 0) {
                return { player1: 0, player2: 0, details: "ì—”ë“œì— ëŒì´ ì—†ìŠµë‹ˆë‹¤." };
            }
            
            // íƒ€ê²Ÿ ì˜ì—­ ë‚´ì˜ ëŒë“¤ë§Œ ê³ ë ¤
            let player1Stones = [];
            let player2Stones = [];
            
            stones.forEach(stone => {
                const distance = Math.sqrt(
                    Math.pow(stone.x - TARGET_CENTER.x, 2) + 
                    Math.pow(stone.y - TARGET_CENTER.y, 2)
                );
                
                if (distance <= TARGET_RADIUS) {
                    if (stone.player === 1) {
                        player1Stones.push({ stone, distance });
                    } else {
                        player2Stones.push({ stone, distance });
                    }
                }
            });
            
            // ê±°ë¦¬ìˆœìœ¼ë¡œ ì •ë ¬
            player1Stones.sort((a, b) => a.distance - b.distance);
            player2Stones.sort((a, b) => a.distance - b.distance);
            
            // ì ìˆ˜ ê³„ì‚°
            if (player1Stones.length === 0 && player2Stones.length === 0) {
                return { player1: 0, player2: 0, details: "ì–‘ íŒ€ ëª¨ë‘ íƒ€ê²Ÿ ì˜ì—­ì— ëŒì´ ì—†ìŠµë‹ˆë‹¤." };
            }
            
            if (player1Stones.length === 0) {
                return { 
                    player1: 0, 
                    player2: player2Stones.length, 
                    details: `Player 2ê°€ ${player2Stones.length}ì  íšë“!` 
                };
            }
            
            if (player2Stones.length === 0) {
                return { 
                    player1: player1Stones.length, 
                    player2: 0, 
                    details: `Player 1ì´ ${player1Stones.length}ì  íšë“!` 
                };
            }
            
            // ê°€ì¥ ê°€ê¹Œìš´ ëŒ ë¹„êµ
            const closestPlayer1 = player1Stones[0].distance;
            const closestPlayer2 = player2Stones[0].distance;
            
            if (closestPlayer1 < closestPlayer2) {
                // Player 1ì´ ê°€ì¥ ê°€ê¹Œì›€ - Player 2ì˜ ê°€ì¥ ê°€ê¹Œìš´ ëŒë³´ë‹¤ ê°€ê¹Œìš´ Player 1ì˜ ëŒë“¤ì´ ì ìˆ˜
                const scoringStones = player1Stones.filter(s => s.distance < closestPlayer2);
                return { 
                    player1: scoringStones.length, 
                    player2: 0, 
                    details: `Player 1ì´ ${scoringStones.length}ì  íšë“!` 
                };
            } else if (closestPlayer2 < closestPlayer1) {
                // Player 2ê°€ ê°€ì¥ ê°€ê¹Œì›€
                const scoringStones = player2Stones.filter(s => s.distance < closestPlayer1);
                return { 
                    player1: 0, 
                    player2: scoringStones.length, 
                    details: `Player 2ê°€ ${scoringStones.length}ì  íšë“!` 
                };
            } else {
                // ë™ì  - ë¬´ë“ì 
                return { player1: 0, player2: 0, details: "ë™ì ìœ¼ë¡œ ë¬´ë“ì ì…ë‹ˆë‹¤." };
            }
        }
        
        // Event listeners
        canvas.addEventListener('mousedown', (e) => {
            if (gameOver || areAnyStoneMoving() || waitingForStones) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Check if click is near throwing area
            const distance = Math.sqrt(
                Math.pow(x - THROWING_AREA.x, 2) + 
                Math.pow(y - THROWING_AREA.y, 2)
            );
            
            if (distance < 50) {
                isDragging = true;
                dragStart = { x: THROWING_AREA.x, y: THROWING_AREA.y };
                dragEnd = { x, y };
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const rect = canvas.getBoundingClientRect();
            dragEnd = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        });
        
        canvas.addEventListener('mouseup', (e) => {
            if (!isDragging || gameOver || waitingForStones) return;
            
            isDragging = false;
            
            // Calculate velocity based on drag
            const dx = dragEnd.x - dragStart.x;
            const dy = dragEnd.y - dragStart.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 10) {
                const velocity = Math.min(distance / 20, 15);
                const angle = Math.atan2(dy, dx);
                
                // Create new stone
                const stone = new Stone(
                    THROWING_AREA.x,
                    THROWING_AREA.y,
                    Math.cos(angle) * velocity,
                    Math.sin(angle) * velocity,
                    currentPlayer
                );
                
                stones.push(stone);
                stonesThrown++;
                
                // Play throw sound
                playThrowSound();
                
                // í”Œë ˆì´ì–´ êµì²´ (ë§¤ë²ˆ ë²ˆê°ˆì•„ê°€ë©°)
                currentPlayer = currentPlayer === 1 ? 2 : 1;
                updateTurnIndicator();
                
                // ì—”ë“œ ì™„ë£Œ ì²´í¬ (ì´ 16ê°œ ëŒ: ê° í”Œë ˆì´ì–´ 8ê°œì”©)
                if (stonesThrown >= 16) {
                    waitingForStones = true;
                    document.getElementById('waitingMessage').style.display = 'block';
                    document.getElementById('turnIndicator').style.display = 'none';
                    
                    // ëŒë“¤ì´ ë©ˆì¶œ ë•Œê¹Œì§€ ê¸°ë‹¤ë¦° í›„ ì—”ë“œ ì¢…ë£Œ
                    checkEndCompletion();
                }
            }
            
            power = 0;
            document.getElementById('powerValue').textContent = '0';
            document.getElementById('powerFill').style.width = '0%';
        });
        
        function areAnyStoneMoving() {
            return stones.some(stone => stone.moving);
        }
        
        function checkEndCompletion() {
            if (!areAnyStoneMoving()) {
                endCurrentEnd();
            } else {
                setTimeout(checkEndCompletion, 500); // 0.5ì´ˆë§ˆë‹¤ ì²´í¬
            }
        }
        
        function endCurrentEnd() {
            waitingForStones = false;
            document.getElementById('waitingMessage').style.display = 'none';
            
            const endScore = calculateEndScore();
            player1Score += endScore.player1;
            player2Score += endScore.player2;
            
            document.getElementById('player1Score').textContent = player1Score;
            document.getElementById('player2Score').textContent = player2Score;
            
            // ì—”ë“œ ê²°ê³¼ í‘œì‹œ
            const endResultDiv = document.getElementById('endResult');
            endResultDiv.textContent = `End ${currentEnd}: ${endScore.details}`;
            endResultDiv.style.display = 'block';
            
            if (endScore.player1 > 0) {
                endResultDiv.className = 'end-result player1-scored';
            } else if (endScore.player2 > 0) {
                endResultDiv.className = 'end-result player2-scored';
            } else {
                endResultDiv.className = 'end-result';
            }
            
            // ì ìˆ˜ íšë“ ì‹œ ì‚¬ìš´ë“œ
            if (endScore.player1 > 0 || endScore.player2 > 0) {
                playScoreSound();
            }
            
            // ì ìˆ˜ë¥¼ ì–»ì€ íŒ€ì˜ ë°˜ëŒ€í¸ì´ ë‹¤ìŒ ì—”ë“œë¥¼ ë¨¼ì € ì‹œì‘ (í•´ë¨¸ ê·œì¹™)
            if (endScore.player1 > 0) {
                currentPlayer = 2; // Player 1ì´ ì ìˆ˜ë¥¼ ì–»ì—ˆìœ¼ë¯€ë¡œ Player 2ê°€ ë¨¼ì € ì‹œì‘
            } else if (endScore.player2 > 0) {
                currentPlayer = 1; // Player 2ê°€ ì ìˆ˜ë¥¼ ì–»ì—ˆìœ¼ë¯€ë¡œ Player 1ì´ ë¨¼ì € ì‹œì‘
            }
            // ë¬´ë“ì ì´ë©´ í˜„ì¬ í”Œë ˆì´ì–´ê°€ ê³„ì† ë¨¼ì € ì‹œì‘
            
            currentEnd++;
            
            if (currentEnd > maxEnds) {
                endGame();
            } else {
                document.getElementById('currentEnd').textContent = currentEnd;
                
                // 2ì´ˆ í›„ ìë™ìœ¼ë¡œ ë‹¤ìŒ ì—”ë“œ ì‹œì‘ (ëŒë“¤ ìë™ ì´ˆê¸°í™”)
                setTimeout(() => {
                    startNextEnd();
                }, 2000);
            }
        }
        
        function startNextEnd() {
            // ë‹¤ìŒ ì—”ë“œë¥¼ ìœ„í•´ ëŒë“¤ ìë™ ì œê±° ë° ì´ˆê¸°í™”
            stones = [];
            stonesThrown = 0;
            endInProgress = false;
            
            document.getElementById('endResult').style.display = 'none';
            document.getElementById('turnIndicator').style.display = 'block';
            
            updateTurnIndicator();
        }
        
        function endGame() {
            gameOver = true;
            let winner;
            let winnerText;
            
            if (player1Score > player2Score) {
                winner = "Player 1 (Blue)";
                winnerText = `ğŸ† ${winner} ìŠ¹ë¦¬! (${player1Score} - ${player2Score})`;
            } else if (player2Score > player1Score) {
                winner = "Player 2 (Red)";
                winnerText = `ğŸ† ${winner} ìŠ¹ë¦¬! (${player2Score} - ${player1Score})`;
            } else {
                winnerText = `ğŸ¤ ë¬´ìŠ¹ë¶€! (${player1Score} - ${player2Score})`;
            }
            
            document.getElementById('gameOver').textContent = winnerText;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('newGameBtn').style.display = 'inline-block';
            document.getElementById('turnIndicator').style.display = 'none';
            document.getElementById('endResult').style.display = 'none';
            
            // ê²Œì„ ì¢…ë£Œ ì‚¬ìš´ë“œ
            playEndSound();
        }
        
        function updateTurnIndicator() {
            const indicator = document.getElementById('turnIndicator');
            const stoneNumber = Math.floor(stonesThrown / 2) + 1; // ê° í”Œë ˆì´ì–´ì˜ ëª‡ ë²ˆì§¸ ëŒì¸ì§€
            const playerStoneNumber = Math.floor((stonesThrown + (currentPlayer === 1 ? 0 : 1)) / 2) + 1;
            
            document.getElementById('stoneNumber').textContent = playerStoneNumber;
            
            if (currentPlayer === 1) {
                indicator.className = 'turn-indicator player1-turn';
                indicator.innerHTML = `Player 1's Turn - Stone <span id="stoneNumber">${playerStoneNumber}</span>/8 - Click and drag to aim and set power`;
            } else {
                indicator.className = 'turn-indicator player2-turn';
                indicator.innerHTML = `Player 2's Turn - Stone <span id="stoneNumber">${playerStoneNumber}</span>/8 - Click and drag to aim and set power`;
            }
        }
        
        function startNewGame() {
            currentPlayer = 1;
            player1Score = 0;
            player2Score = 0;
            currentEnd = 1;
            stonesThrown = 0;
            gameOver = false;
            endInProgress = false;
            waitingForStones = false;
            stones = [];
            
            document.getElementById('player1Score').textContent = '0';
            document.getElementById('player2Score').textContent = '0';
            document.getElementById('currentEnd').textContent = '1';
            document.getElementById('maxEnds').textContent = maxEnds;
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('newGameBtn').style.display = 'none';
            document.getElementById('endResult').style.display = 'none';
            document.getElementById('waitingMessage').style.display = 'none';
            document.getElementById('turnIndicator').style.display = 'block';
            
            updateTurnIndicator();
        }
        
        // Game loop
        function gameLoop() {
            // Update stones
            stones.forEach(stone => stone.update());
            
            // Check collisions
            checkStoneCollisions();
            
            // Draw everything
            draw();
            
            requestAnimationFrame(gameLoop);
        }
        
        // Initialize game
        document.getElementById('maxEnds').textContent = maxEnds;
        updateTurnIndicator();
        gameLoop();
    </script>
</body>
</html>
